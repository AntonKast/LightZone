Index: dcraw/dcraw_lz.c
===================================================================
--- dcraw.orig/dcraw_lz.c	2015-04-19 16:10:46.024330708 +0900
+++ dcraw/dcraw_lz.c	2015-04-19 16:10:46.020331202 +0900
@@ -1,4 +1,8 @@
 /*
+ * OpenMP multithread version of dcraw
+ * based on UFRaw dcraw_indi.c by Udi Fuchs
+ */
+/*
    dcraw.c -- Dave Coffin's raw photo decoder
    Copyright 1997-2015 by Dave Coffin, dcoffin a cybercom o net
 
@@ -105,6 +109,15 @@
 #define ushort unsigned short
 #endif
 
+#ifdef _OPENMP
+#include <omp.h>
+#define uf_omp_get_thread_num() omp_get_thread_num()
+#define uf_omp_get_num_threads() omp_get_num_threads()
+#else
+#define uf_omp_get_thread_num() 0
+#define uf_omp_get_num_threads() 1
+#endif
+
 /*
    All global variables are defined here, and all functions that
    access them are prefixed with "CLASS".  Note that a thread-safe
@@ -4073,6 +4086,19 @@
   merror (fimg, "wavelet_denoise()");
   temp = fimg + size*3;
   if ((nc = colors) == 3 && filters) nc++;
+#ifdef _OPENMP
+#if defined(__sun) && !defined(__GNUC__)	/* Fix UFRaw bug #3205673 - NKBJ */
+    #pragma omp parallel for				\
+    default(none)					\
+    shared(nc,image,scale,size,noise)				\
+    private(c,i,hpass,lev,lpass,row,col,thold,fimg,temp)
+#else
+    #pragma omp parallel for				\
+    default(none)					\
+    shared(nc,image,iheight,iwidth,scale,threshold,size)				\
+    private(c,i,hpass,lev,lpass,row,col,thold,fimg,temp)
+#endif
+#endif
   FORC(nc) {			/* denoise R,G1,B,G3 individually */
     for (i=0; i < size; i++)
       fimg[i] = 256 * sqrt(image[i][c] << scale);
@@ -4298,6 +4324,9 @@
 {
   unsigned row, col, y, x, f, c, sum[8];
 
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (row=0; row < height; row++)
     for (col=0; col < width; col++) {
       if (col==border && row >= border && row < height-border)
@@ -4324,7 +4353,15 @@
 
   if (verbose) fprintf (stderr,_("Bilinear interpolation...\n"));
   if (filters == 9) size = 6;
+#ifdef _OPENMP
+    #pragma omp parallel default(shared) \
+    private(ip, sum, f, c, i, x, y, row, col, shift, color, pix)
+#endif
+{
   border_interpolate(1);
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (row=0; row < size; row++)
     for (col=0; col < size; col++) {
       ip = code[row][col]+1;
@@ -4347,6 +4384,9 @@
 	  *ip++ = 256 / sum[c];
 	}
     }
+#ifdef _OPENMP
+    #pragma omp for
+#endif
   for (row=1; row < height-1; row++)
     for (col=1; col < width-1; col++) {
       pix = image[row*width+col];
@@ -4357,6 +4397,7 @@
       for (i=colors; --i; ip+=2)
 	pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;
     }
+} /* pragma omp parallel */
 }
 
 /*
@@ -4395,7 +4436,7 @@
     +1,-1,+1,+1,0,0x88, +1,+0,+1,+2,0,0x08, +1,+0,+2,-1,0,0x40,
     +1,+0,+2,+1,0,0x10
   }, chood[] = { -1,-1, -1,0, -1,+1, 0,+1, +1,+1, +1,0, +1,-1, 0,-1 };
-  ushort (*brow[5])[4], *pix;
+  ushort (*brow[4])[4], *pix;
   int prow=8, pcol=2, *ip, *code[16][16], gval[8], gmin, gmax, sum[4];
   int row, col, x, y, x1, x2, y1, y2, t, weight, grads, color, diag;
   int g, diff, thold, num, c;
@@ -4405,7 +4446,7 @@
 
   if (filters == 1) prow = pcol = 16;
   if (filters == 9) prow = pcol =  6;
-  ip = (int *) calloc (prow*pcol, 1280);
+  int *ipalloc = ip = (int *) calloc (prow*pcol, 1280);
   merror (ip, "vng_interpolate()");
   for (row=0; row < prow; row++)		/* Precalculate for VNG */
     for (col=0; col < pcol; col++) {
@@ -4437,11 +4478,22 @@
 	  *ip++ = 0;
       }
     }
-  brow[4] = (ushort (*)[4]) calloc (width*3, sizeof **brow);
-  merror (brow[4], "vng_interpolate()");
-  for (row=0; row < 3; row++)
-    brow[row] = brow[4] + row*width;
-  for (row=2; row < height-2; row++) {		/* Do VNG interpolation */
+#ifdef _OPENMP
+    #pragma omp parallel				\
+    default(none)					\
+    shared(image,code,prow,pcol,width,height,colors)			\
+    private(row,col,g,brow,pix,ip,gval,diff,gmin,gmax,thold,sum,color,num,c,t)
+#endif
+{
+  ushort rowtmp[4][width*4];
+  int slice = (height - 4) / uf_omp_get_num_threads();
+  int start_row = 2 + slice * uf_omp_get_thread_num();
+  int end_row = MIN(start_row + slice, height - 2);
+  for (row = start_row; row < end_row; row++) {	/* Do VNG interpolation */
+
+    for (g = 0; g < 4; g++)
+      brow[g] = &rowtmp[(row + g - 2) % 4][0];
+
     for (col=2; col < width-2; col++) {
       pix = image[row*width+col];
       ip = code[row % prow][col % pcol];
@@ -4485,15 +4537,15 @@
 	brow[2][col][c] = CLIP(t);
       }
     }
-    if (row > 3)				/* Write buffer to image */
+    if (row > start_row + 1)				/* Write buffer to image */
       memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);
-    for (g=0; g < 4; g++)
-      brow[(g-1) & 3] = brow[g];
   }
-  memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);
-  memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);
-  free (brow[4]);
-  free (code[0][0]);
+  if (row == height - 2) {
+    memcpy (image[(row-2)*width+2], brow[0]+2, (width-4)*sizeof *image);
+    memcpy (image[(row-1)*width+2], brow[1]+2, (width-4)*sizeof *image);
+  }
+} /* pragma omp parallel */
+  free(ipalloc);
 }
 
 /*
@@ -4505,10 +4557,20 @@
   int row, col, diff[2], guess[2], c, d, i;
   ushort (*pix)[4];
 
-  border_interpolate(3);
   if (verbose) fprintf (stderr,_("PPG interpolation...\n"));
 
+#ifdef _OPENMP
+    #pragma omp parallel				\
+    default(none)					\
+    shared(image,dir,diff,width,height,filters)				\
+    private(row,col,i,d,c,pix,guess)
+#endif
+{
+  border_interpolate(3);
 /*  Fill in the green layer with gradients and pattern recognition: */
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (row=3; row < height-3; row++)
     for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {
       pix = image + row*width+col;
@@ -4525,6 +4587,9 @@
       pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);
     }
 /*  Calculate red and blue for each green pixel:		*/
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (row=1; row < height-1; row++)
     for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {
       pix = image + row*width+col;
@@ -4533,6 +4598,9 @@
 			- pix[-d][1] - pix[d][1]) >> 1);
     }
 /*  Calculate blue for red pixels and vice versa:		*/
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (row=1; row < height-1; row++)
     for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {
       pix = image + row*width+col;
@@ -4548,6 +4616,7 @@
       else
 	pix[0][c] = CLIP((guess[0]+guess[1]) >> 2);
     }
+} /* pragma omp parallel */
 }
 
 void CLASS cielab (ushort rgb[3], short lab[3])
@@ -4557,13 +4626,22 @@
   static float cbrt[0x10000], xyz_cam[3][4];
 
   if (!rgb) {
+#ifdef _OPENMP
+        #pragma omp for
+#endif
     for (i=0; i < 0x10000; i++) {
       r = i / 65535.0;
       cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
     }
+#ifdef _OPENMP
+        #pragma omp for
+#endif
     for (i=0; i < 3; i++)
       for (j=0; j < colors; j++)
 	for (xyz_cam[i][j] = k=0; k < 3; k++)
+#ifdef _OPENMP
+        #pragma omp atomic
+#endif
 	  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];
     return;
   }
@@ -4829,6 +4907,12 @@
 
   if (verbose) fprintf (stderr,_("AHD interpolation...\n"));
 
+#ifdef _OPENMP
+    #pragma omp parallel				\
+    default(shared)					\
+    private(top, left, row, col, pix, rix, lix, c, val, d, tc, tr, i, j, ldiff, abdiff, leps, abeps, hm, buffer, rgb, lab, homo)
+#endif
+{
   cielab (0,0);
   border_interpolate(5);
   buffer = (char *) malloc (26*TS*TS);
@@ -4837,6 +4921,9 @@
   lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);
   homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);
 
+#ifdef _OPENMP
+        #pragma omp for
+#endif
   for (top=2; top < height-5; top += TS-6)
     for (left=2; left < width-5; left += TS-6) {
 
@@ -4919,6 +5006,7 @@
       }
     }
   free (buffer);
+} /* pragma omp parallel */
 }
 #undef TS
 
@@ -9374,6 +9462,9 @@
   img = (ushort (*)[4]) calloc (high, wide*sizeof *img);
   merror (img, "fuji_rotate()");
 
+#ifdef _OPENMP
+    #pragma omp parallel for default(shared) private(row,col,ur,uc,r,c,fr,fc,pix,i)
+#endif
   for (row=0; row < high; row++)
     for (col=0; col < wide; col++) {
       ur = r = fuji_width + (row-col)*step;
